# Express JS 기초


## ExpressJS 구조

- ExpressJS는 크게 **어플리케이션, 미들웨어, 라우팅, 요청객체, 응답객체**로 이루어져있다.

<br/>

## 1. 애플리케이션(Application)

- 애플리케이션은 서버의 **핵심 객체**이다. 애플리케이션 객체는 서버를 구성하고 라우팅, 미들웨어, 서버 설정 등을 관리하는 역할을 한다.

### 예시 코드:
```javascript
const express = require('express');
const app = express();  // Express 애플리케이션 생성

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

<br/>

## 2. 미들웨어(MiddleWare)

- 미들웨어는 요청(Request)과 응답(Response) 사이에서 중간에 처리해야 할 작업을 수행하는 함수이다. 
- 미들웨어는 라우팅 전에 공통 작업을 처리하거나, 에러 핸들링 등을 할 수 있다.

### 예시코드:
```javascript
function logger(req, res, next) {
    console.log('i am logger');
    next() // 다음 미들웨어나 라우팅으로 요청을 전달
}

function logger2(req, res, next) {
    console.log('i am logger2');
    next() // 다음 미들웨어나 라우팅으로 요청을 전달
}

app.use(logger);
app.use(logger2);
```

<br/>

## 3. 라우팅(Routing)
- 라우팅은 특정 경로로 들어오는 요청에 대해 어떻게 응답할지 결정하는 역할을 한다. 
- 즉, **URL과 HTTP 메소드(GET, POST, 등)** 에 따라 서버가 특정 동작을 실행하도록 설정한다.

### 예시코드: 
```javascript
app.get('/hello', (req, res) => {
  res.send('Hello, world!');
});
```

<br/>

## 4. 요청 객체(Request Object)

- **요청 객체(req)** 는 클라이언트가 서버로 보낸 요청에 대한 모든 정보를 담고 있는 객체이다. 
- 요청한 URL, 헤더, 파라미터, 본문 등의 데이터를 포함한다.

### 예시코드:
```javascript
app.get('/user/:id', (req, res) => {
  const userId = req.params.id;  // URL 파라미터에서 'id' 값 추출
  res.send(`User ID: ${userId}`);
});
```

<br/>

## 5. 응답 객체(Response Object)

- **응답 객체(res)** 는 서버가 클라이언트에게 응답할 때 필요한 메소드와 속성들을 제공하는 객체이다. 
- 이 객체를 통해 클라이언트에게 데이터를 보낼 수 있다.


```javascript
app.get('/hello', (req, res) => {
  res.status(200).send('Hello, world!');  // 상태 코드 200과 함께 응답 전송
});
```


<br/>

## ExpressJS vs NestJS 비교

| **구성 요소**       | **Express**                                                      | **NestJS**                                                                      |
|---------------------|------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **애플리케이션**     | `app` 객체로 서버를 구성하고 시작                                | `AppModule`을 통해 모듈 기반으로 애플리케이션을 구성                             |
| **미들웨어**        | `app.use()`로 직접 미들웨어 연결                                 | `@Middleware()` 데코레이터를 사용하여 미들웨어를 모듈 단위로 적용               |
| **라우팅**          | `app.get()`로 경로와 메소드에 따른 요청 처리                     | `@Controller()` 데코레이터와 함께 `@Get()`, `@Post()` 등의 데코레이터로 라우팅 설정 |
| **비즈니스 로직**    | 비즈니스 로직을 라우터와 같은 곳에서 처리하는 경우가 많음         | `@Injectable()`로 선언한 서비스(Service)에 비즈니스 로직을 분리하여 관리         |
| **모듈 시스템**      | 없음. 라우팅과 파일로 관리                                       | 모듈(Module) 시스템을 통해 애플리케이션을 더 체계적으로 구성 가능                |
| **의존성 주입(DI)**  | 없음. 직접 객체를 생성하고 사용하는 방식                         | 의존성 주입을 통해 클래스 간의 의존성을 관리하고 테스트 용이성 증가              |
| **구조적 설계**      | 유연하지만 구조화는 개발자가 직접 해야 함                        | 구조가 명확히 정의되어 있고, 모듈, 컨트롤러, 서비스로 분리하여 유지보수성 향상   |
| **확장성**          | 작은 프로젝트에 적합, 커질수록 구조화가 필요                     | 큰 규모의 프로젝트에 적합, 기본적으로 모듈화되어 확장성과 유지보수성이 높음      |
| **학습 곡선**        | 상대적으로 빠르고 간단하게 배울 수 있음                          | 구조화된 설계 덕분에 학습 시간이 필요하지만, 대규모 프로젝트에 유리함        |

